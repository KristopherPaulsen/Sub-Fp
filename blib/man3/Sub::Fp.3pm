.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.29)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Sub::Fp 3pm"
.TH Sub::Fp 3pm "2019-01-12" "perl v5.22.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Sub::Fp \- A Clojure / Python Toolz / Lodash inspired Functional Utility Library
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
This library provides numerous functional programming utility methods,
as well as functional varients of native in-built methods, to allow for consistent,
concise code.
.SH "SUBROUTINES/METHODS"
.IX Header "SUBROUTINES/METHODS"
.SH "EXPORT"
.IX Header "EXPORT"
.Vb 10
\&    incr         reduces   flatten
\&    drop_right  drop      take_right  take
\&    assoc       maps      decr        chain
\&    first       end       subarray    partial
\&    _\|_          find      filter      some
\&    none        uniq      bool        spread   every
\&    len         is_array  is_hash     to_keys  to_vals
\&    noop        identity  is_empty    flow     eql
\&    is_sub      to_pairs  for_each    apply
\&    get         second
.Ve
.SS "incr"
.IX Subsection "incr"
Increments the supplied number by 1
.PP
.Vb 1
\&    incr(1)
\&
\&    # => 2
.Ve
.SS "decr"
.IX Subsection "decr"
Decrements the supplied number by 1
.PP
.Vb 1
\&    decr(2)
\&
\&    # => 1
.Ve
.SS "once"
.IX Subsection "once"
Creates a function that is restricted to invoking func once.
Repeat calls to the function return the value of the first invocation.
.PP
.Vb 5
\&    my $times_called = 0;
\&    my $sub          = once(sub {
\&        $times_called++;
\&        return "I was only called $times_called time"
\&    });
\&
\&    $sub\->(); # "I was only called 1 time"
\&    $sub\->(); # "I was only called 1 time"
\&    $sub\->(); # etc
.Ve
.SS "apply"
.IX Subsection "apply"
Calls the supplied function with the array of arguments, spreading the
arguments into the function it invokes
.PP
.Vb 3
\&    my $sum_all_nums = sub {
\&        my $num        = shift;
\&        my $second_num = shift;
\&
\&        return $num + $second_num;
\&    };
\&
\&    apply($sum_all_nums, [100, 200]);
\&    # same as $sum_all_nums\->(100, 200)
\&
\&    # => 300
.Ve
.SS "range"
.IX Subsection "range"
Creates an array of numbers (positive and/or negative) progressing from start up to, but not including, end.
A step of \-1 is used if a negative start is specified without an end or step.
If end is not specified, it's set to start with start then set to 0.
.PP
.Vb 1
\&    range(10);
\&
\&    # [1,2,3,4,5,6,7,8,9]
\&
\&
\&    range(1,10);
\&
\&    # [1,2,3,4,5,6,7,8,9]
\&
\&    range(\-1, \-10);
\&
\&    # [\-1, \-2, \-3, \-4, \-5, \-6 ,\-7, \-8, \-9]
\&
\&    range(1, 4, 0);
\&
\&    # [1, 1, 1]
\&
\&
\&    #Ranges that "dont make sense" will return empty arrays
\&
\&    range(\-1, \-4, 0);
\&
\&    # []
\&
\&    range(100, 1, 0)
\&
\&    # []
\&
\&    range(0,0,0)
\&
\&    # []
\&
\&    range(0, \-100, 100)
\&
\&    # []
\&
\&    range(0, 100, \-100)
\&
\&    # []
\&
\&    #etc...
.Ve
.SS "for_each"
.IX Subsection "for_each"
Iterates over elements of collection and invokes iteratee for each element. The iteratee is invoked with three arguments: (value, index|key, collection).
.PP
.Vb 4
\&    for_each(sub {
\&       my $num = shift;
\&       print $num;
\&    }, [1,2,3]);
\&
\&
\&    for_each(sub {
\&       my ($num, $idx, $coll) = @_;
\&       print $idx;
\&    }, [1,2,3])
\&
\&    # 0 1 2
\&
\&    for_each(sub {
\&       my ($num, $idx, $coll) = @_;
\&       print Dumper $coll;
\&    }, [1,2,3])
\&
\&    #   [1,2,3],
\&    #   [1,2,3],
\&    #   [1,2,3]
.Ve
.SS "maps"
.IX Subsection "maps"
Creates an array of values by running each element in collection thru iteratee.
The iteratee is invoked with three arguments:
(value, index|key, collection).
.PP
.Vb 4
\&    maps(sub {
\&        my $num = shift;
\&        return $num + 1;
\&    }, [1,1,1]);
\&
\&    # [2,2,2]
.Ve
.SS "reduces"
.IX Subsection "reduces"
Reduces collection to a value which is the accumulated result of running each element in collection thru iteratee,
where each successive invocation is supplied the return value of the previous.
If accumulator is not given, the first element of collection is used as the initial value.
The iteratee is invoked with four arguments:
(accumulator, value, index|key, collection).
.PP
.Vb 1
\&    # Implicit Accumulator
\&
\&    reduces(sub {
\&        my ($sum, $num) = @_;
\&
\&        return $sum + $num;
\&    }, [1,1,1]);
\&
\&    # 3
\&
\&
\&    # Explict Accumulator
\&
\&    reduces(sub {
\&        my ($accum, $num) = @_;
\&        return {
\&            spread($accum),
\&            key => $num,
\&        }
\&    }, {}, [1,2,3]);
\&
\&    # {
\&    #    key => 1,
\&    #    key => 2,
\&    #    key => 3,
\&    # }
.Ve
.SS "flatten"
.IX Subsection "flatten"
Flattens array a single level deep.
.PP
.Vb 1
\&    flatten([1,1,1, [2,2,2]]);
\&
\&    # [1,1,1,2,2,2];
.Ve
.SS "pop / pushes / shifts / unshifts"
.IX Subsection "pop / pushes / shifts / unshifts"
Works the same as builtin pop / push etc etc, with mutations,
except it uses references instead of @ lists.
.PP
.Vb 1
\&    my $array = [1,2,3];
\&
\&    pops($array)
\&
\&    # 3
\&
\&    my $array = [1,2,3];
\&
\&    pushes($array, 4);
\&
\&    # [1,2,3,4]
.Ve
.SS "drop"
.IX Subsection "drop"
Creates a slice of array with n elements dropped from the beginning.
.PP
.Vb 1
\&    drop([1,2,3])
\&
\&    # [2,3];
\&
\&    drop(2, [1,2,3])
\&
\&    # [3]
\&
\&    drop(5, [1,2,3])
\&
\&    # []
\&
\&    drop(0, [1,2,3])
\&
\&    # [1,2,3]
.Ve
.SS "drop_right"
.IX Subsection "drop_right"
Creates a slice of array with n elements dropped from the end.
.PP
.Vb 1
\&    drop_right([1,2,3]);
\&
\&    # [1,2]
\&
\&    drop_right(2, [1,2,3])
\&
\&    # [1]
\&
\&    drop_right(5, [1,2,3])
\&
\&    # []
\&
\&    drop_right(0, [1,2,3])
\&
\&    #[1,2,3]
.Ve
.SS "take"
.IX Subsection "take"
Creates a slice of array with n elements taken from the beginning.
.PP
.Vb 1
\&    take([1, 2, 3);
\&
\&    # [1]
\&
\&    take(2, [1, 2, 3]);
\&
\&    # [1, 2]
\&
\&    take(5, [1, 2, 3]);
\&
\&    # [1, 2, 3]
\&
\&    take(0, [1, 2, 3]);
\&
\&    # []
.Ve
.SS "take_right"
.IX Subsection "take_right"
Creates a slice of array with n elements taken from the end.
.PP
.Vb 1
\&    take_right([1, 2, 3]);
\&
\&    # [3]
\&
\&    take_right(2, [1, 2, 3]);
\&
\&    # [2, 3]
\&
\&    take_right(5, [1, 2, 3]);
\&
\&    # [1, 2, 3]
\&
\&    take_right(0, [1, 2, 3]);
\&
\&    # []
.Ve
.SS "second"
.IX Subsection "second"
Returns the second item in an array
.PP
.Vb 1
\&    second(["I", "am", "a", "string"])
\&
\&    # "am"
\&
\&    second([5,4,3,2,1])
\&
\&    # 4
.Ve
.SS "first"
.IX Subsection "first"
Returns the first item in an array
.PP
.Vb 1
\&    first(["I", "am", "a", "string"])
\&
\&    # "I"
\&
\&    first([5,4,3,2,1])
\&
\&    # 5
.Ve
.SS "end"
.IX Subsection "end"
Returns the end, or last item in an array
.PP
.Vb 1
\&    end(["I", "am", "a", "string"])
\&
\&    # "string"
\&
\&    end([5,4,3,2,1])
\&
\&    # 1
.Ve
.SS "len"
.IX Subsection "len"
Returns the length of the collection.
If an array, returns the number of items.
If a hash, the number of key-val pairs.
If a string, the number of chars (following built-in split)
.PP
.Vb 1
\&    len([1,2,3,4])
\&
\&    # 4
\&
\&    len("Hello")
\&
\&    # 5
\&
\&    len({ key => \*(Aqval\*(Aq, key2 => \*(Aqval\*(Aq})
\&
\&    #2
\&
\&    len([])
\&
\&    # 0
.Ve
.SS "noop"
.IX Subsection "noop"
A function that does nothing (like our government), and returns undef
.PP
.Vb 1
\&    noop()
\&
\&    # undef
.Ve
.SS "identity"
.IX Subsection "identity"
A function that returns its first argument
.PP
.Vb 1
\&    identity()
\&
\&    # undef
\&
\&    identity(1)
\&
\&    # 1
\&
\&    identity([1,2,3])
\&
\&    # [1,2,3]
.Ve
.SS "eql"
.IX Subsection "eql"
Returns 0 or 1 if the two values have == equality, with convience wrapping
for different types (no need to use eq vs ==). Follows internal perl rules
on equality following strings vs numbers in perl.
.PP
.Vb 1
\&    eql([], [])
\&
\&    # 1
\&
\&    eql(1,1)
\&
\&    # 1
\&
\&
\&    my $obj = {};
\&
\&    eql($obj, $obj);
\&
\&    # 1
\&
\&
\&    eql("123", 123)
\&
\&    # 1  \*(AqFollowing perls internal rules on comparing scalars\*(Aq
\&
\&
\&    eql({ key => \*(Aqval\*(Aq }, {key => \*(Aqval\*(Aq});
\&
\&    # 0 \*(AqOnly identity equality\*(Aq
.Ve
.SS "is_sub"
.IX Subsection "is_sub"
Returns 0 or 1 if the argument is a sub ref
.PP
.Vb 1
\&    is_sub()
\&
\&    # 0
\&
\&    is_sub(sub {})
\&
\&    # 1
\&
\&    my $sub = sub {};
\&    is_sub($sub)
\&
\&    # 1
.Ve
.SS "is_array"
.IX Subsection "is_array"
Returns 0 or 1 if the argument is an array
.PP
.Vb 1
\&    is_array()
\&
\&    # 0
\&
\&    is_array([1,2,3])
\&
\&    # 1
.Ve
.SS "is_hash"
.IX Subsection "is_hash"
Returns 0 or 1 if the argument is a hash
.PP
.Vb 1
\&    is_hash()
\&
\&    # 0
\&
\&    is_hash({ key => \*(Aqval\*(Aq })
\&
\&    # 1
.Ve
.SS "is_empty"
.IX Subsection "is_empty"
Returns 1 if the argument is 'empty',
0 if not empty. Used on strings, arrays, hashes.
.PP
.Vb 1
\&    is_empty()
\&
\&    # 1
\&
\&    is_empty([])
\&
\&    # 1
\&
\&    is_empty([1,2,3])
\&
\&    # 0
\&
\&    is_empty({ key => \*(Aqval\*(Aq })
\&
\&    # 0
\&
\&    is_empty("I am a string")
\&
\&    # 0
.Ve
.SS "get"
.IX Subsection "get"
Returns value from hash, string, array based on key/idx provided.
Returns default value if provided key/idx does not exist on collection.
Only works one level deep;
.PP
.Vb 3
\&    my $hash = {
\&        key1 => \*(Aqvalue1\*(Aq,
\&    };
\&
\&    get($hash, \*(Aqkey1\*(Aq);
\&
\&    # \*(Aqvalue1\*(Aq
\&
\&
\&    my $array = [100, 200, 300]
\&
\&    get($array, 1);
\&
\&    # 200
\&
\&
\&    my $string = "Hello";
\&
\&    get($string, 1);
\&
\&    # e
\&
\&
\&    # Also has the ability to supply default\-value when key/idx does not exist
\&
\&    my $hash = {
\&        key1 => \*(Aqvalue1\*(Aq,
\&    };
\&
\&    get($hash, \*(Aqkey2\*(Aq, "DEFAULT HERE");
\&
\&    # \*(AqDEFAULT HERE\*(Aq
.Ve
.SS "spread"
.IX Subsection "spread"
Destructures an array / hash into non-ref context.
Destructures a string into an array of chars (following in-built split)
.PP
.Vb 1
\&    spread([1,2,3,4])
\&
\&    # 1,2,3,4
\&
\&    spread({ key => \*(Aqval\*(Aq })
\&
\&    # key,\*(Aqval\*(Aq
\&
\&    spread("Hello")
\&
\&    # \*(AqH\*(Aq,\*(Aqe\*(Aq,\*(Aql\*(Aq,\*(Aql\*(Aq,\*(Aqo\*(Aq
.Ve
.SS "bool"
.IX Subsection "bool"
Returns 0 or 1 based on truthiness of argument, following
internal perl rules based on ternary coercion
.PP
.Vb 1
\&    bool([])
\&
\&    # 1
\&
\&    bool("hello!")
\&
\&    # 1
\&
\&    bool()
\&
\&    # 0
\&
\&    bool(undef)
\&
\&    # 0
.Ve
.SS "to_keys"
.IX Subsection "to_keys"
Creates an array of the key names in a hash,
indicies of an array, or chars in a string
.PP
.Vb 1
\&    to_keys([1,2,3])
\&
\&    # [0,1,2]
\&
\&    to_keys({ key => \*(Aqval\*(Aq, key2 => \*(Aqval2\*(Aq })
\&
\&    # [\*(Aqkey\*(Aq, \*(Aqkey2\*(Aq]
\&
\&    to_keys("Hey")
\&
\&    # [0, 1, 2];
.Ve
.SS "to_vals"
.IX Subsection "to_vals"
Creates an array of the values in a hash, of an array, or string.
.PP
.Vb 1
\&    to_vals([1,2,3])
\&
\&    # [0,1,2]
\&
\&    to_vals({ key => \*(Aqval\*(Aq, key2 => \*(Aqval2\*(Aq })
\&
\&    # [\*(Aqval\*(Aq, \*(Aqval2\*(Aq]
\&
\&    to_vals("Hey");
\&
\&    # [\*(AqH\*(Aq,\*(Aqe\*(Aq,\*(Aqy\*(Aq];
.Ve
.SS "to_pairs"
.IX Subsection "to_pairs"
Creates an array of key-value, or idx-value pairs from arrays, hashes, and strings.
If used on a hash, key-pair order can not be guaranteed;
.PP
.Vb 1
\&    to_pairs("I am a string");
\&
\&    # [
\&    #  [0, "I"],
\&    #  [1, "am"],
\&    #  [2, "a"],
\&    #  [3, "string"]
\&    # ]
\&
\&    to_pairs([100, 101, 102]);
\&
\&    # [
\&    #  [0, 100],
\&    #  [1, 102],
\&    #  [2, 103],
\&    # ]
\&
\&    to_pairs({ key1 => \*(Aqvalue1\*(Aq, key2 => \*(Aqvalue2\*(Aq });
\&
\&    # [
\&    #   [key1, \*(Aqvalue1\*(Aq],
\&    #   [key2, \*(Aqvalue2\*(Aq]
\&    # ]
\&
\&    to_pairs({ key1 => \*(Aqvalue1\*(Aq, key2 => { nested => \*(AqnestedValue\*(Aq }});
\&
\&    # [
\&    #   [key1, \*(Aqvalue1\*(Aq],
\&    #   [key2, { nested => \*(AqnestedValue\*(Aq }]
\&    # ]
.Ve
.SS "uniq"
.IX Subsection "uniq"
Creates a duplicate-free version of an array,
in which only the first occurrence of each element is kept.
The order of result values is determined by the order they occur in the array.
.PP
.Vb 1
\&    uniq([2,1,2])
\&
\&    # [2,1]
\&
\&    uniq(["Hi", "Howdy", "Hi"])
\&
\&    # ["Hi", "Howdy"]
.Ve
.SS "assoc"
.IX Subsection "assoc"
Returns new hash, or array, with the updated value at index / key.
Shallow updates only
.PP
.Vb 1
\&    assoc([1,2,3,4,5,6,7], 0, "item")
\&
\&    # ["item",2,3,4,5,6,7]
\&
\&    assoc({ name => \*(Aqsally\*(Aq, age => 26}, \*(Aqname\*(Aq, \*(Aqjimmy\*(Aq)
\&
\&    # { name => \*(Aqjimmy\*(Aq, age => 26}
.Ve
.SS "subarray"
.IX Subsection "subarray"
Returns a subset of the original array, based on
start index (inclusive) and end idx (not-inclusive)
.PP
.Vb 1
\&    subarray(["first", "second", "third", "fourth"], 0,2)
\&
\&    # ["first", "second"]
.Ve
.SS "find"
.IX Subsection "find"
Iterates over elements of collection, returning the first element predicate returns truthy for.
.PP
.Vb 10
\&    my $people = [
\&        {
\&            name => \*(Aqjohn\*(Aq,
\&            age => 25,
\&        },
\&        {
\&            name => \*(AqSally\*(Aq,
\&            age => 25,
\&        }
\&    ]
\&
\&    find(sub {
\&        my $person = shift;
\&        return eql($person\->{\*(Aqname\*(Aq}, \*(Aqsally\*(Aq)
\&    }, $people);
\&
\&    # { name => \*(Aqsally\*(Aq, age => 25 }
.Ve
.SS "filter"
.IX Subsection "filter"
Iterates over elements of collection, returning only elements the predicate returns truthy for.
.PP
.Vb 10
\&    my $people = [
\&        {
\&            name => \*(Aqjohn\*(Aq,
\&            age => 25,
\&        },
\&        {
\&            name => \*(AqSally\*(Aq,
\&            age => 25,
\&        },
\&        {
\&            name => \*(AqOld Greg\*(Aq,
\&            age => 100,
\&        }
\&    ]
\&
\&    filter(sub {
\&        my $person = shift;
\&        return $person\->{\*(Aqage\*(Aq} < 30;
\&    }, $people);
\&
\&    # [
\&    #    {
\&    #        name => \*(Aqjohn\*(Aq,
\&    #        age => 25,
\&    #    },
\&    #    {
\&    #        name => \*(AqSally\*(Aq,
\&    #        age => 25,
\&    #    }
\&    # ]
.Ve
.SS "none"
.IX Subsection "none"
If one element is found to return truthy for the given predicate, none returns 0
.PP
.Vb 10
\&    my $people = [
\&        {
\&            name => \*(Aqjohn\*(Aq,
\&            age => 25,
\&        },
\&        {
\&            name => \*(AqSally\*(Aq,
\&            age => 25,
\&        },
\&        {
\&            name => \*(AqOld Greg\*(Aq,
\&            age => 100,
\&        }
\&    ]
\&
\&    none(sub {
\&        my $person = shift;
\&        return $person\->{\*(Aqage\*(Aq} > 99;
\&    }, $people);
\&
\&    # 0
\&
\&    none(sub {
\&        my $person = shift;
\&        return $person\->{\*(Aqage\*(Aq} > 101;
\&    }, $people);
\&
\&    # 1
.Ve
.SS "every"
.IX Subsection "every"
Itterates through each element in the collection, and checks if element makes predicate
return truthy. If all elements cause predicate to return truthy, every returns 1;
.PP
.Vb 4
\&    every(sub {
\&        my $num = shift;
\&        $num > 0;
\&    }, [1,2,3,4]);
\&
\&    # 1
\&
\&    every(sub {
\&        my $num = shift;
\&        $num > 2;
\&    }, [1,2,3,4]);
\&
\&    # 0
.Ve
.SS "some"
.IX Subsection "some"
Checks if predicate returns truthy for any element of collection.
Iteration is stopped once predicate returns truthy.
.PP
.Vb 4
\&    some(sub {
\&        my $num = shift;
\&        $num > 0;
\&    }, [1,2,3,4]);
\&
\&    # 1
\&
\&    some(sub {
\&        my $num = shift;
\&        $num > 2;
\&    }, [1,2,3,4]);
\&
\&    # 1
.Ve
.SS "partial"
.IX Subsection "partial"
Creates a function that invokes func with partials prepended to the arguments it receives.
(funcRef, args)
.PP
.Vb 2
\&    my $add_three_nums = sub {
\&        my ($a, $b, $c) = @_;
\&
\&        return $a + $b + $c;
\&    };
\&
\&    my $add_two_nums = partial($add_three_nums, 1);
\&
\&    $add_two_nums\->(1,1)
\&
\&    # 3
\&
\&
\&    # Can also use _\|_ to act as a placeholder
\&
\&    my $add_four_strings = sub {
\&        my ($a, $b, $c, $d) = @_;
\&
\&        return $a . $b . $c . $d;
\&    };
\&
\&    my $add_two_strings = partial($add_four_strings, "first ", _\|_, "third ", _\|_);
\&
\&    $add_two_strings\->("second ", "third ")
\&
\&    # "first second third fourth"
.Ve
.SS "chain"
.IX Subsection "chain"
Composes functions, left to right, and invokes them, returning
the result. Accepts an expression as the first argument, to be passed
as the first argument to the proceding function
.PP
.Vb 8
\&    chain(
\&        [1,2,3, [4,5,6]],
\&        sub {
\&            my $array = shift;
\&            return [spread($array), 7]
\&        },
\&        \e&flatten,
\&    );
\&
\&    # [1,2,3,4,5,6,7]
\&
\&
\&    # Invokes first function, and uses that as start value for next func
\&    chain(
\&        sub { [1,2,3, [4,5,6]] },
\&        sub {
\&            my $array = shift;
\&            return [spread($array), 7]
\&        },
\&        \e&flatten,
\&    )
\&
\&    # [1,2,3,4,5,6,7]
.Ve
.SS "flow"
.IX Subsection "flow"
Creates a function that returns the result of invoking the given functions,
where each successive invocation is supplied the return value of the previous.
.PP
.Vb 1
\&    my $addTwo = flow(\e&incr, \e&incr);
\&
\&    $addTwo\->(1);
\&
\&    # 3
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Kristopher C. Paulsen, \f(CW\*(C`<kristopherpaulsen+cpan at gmail.com>\*(C'\fR
.SH "BUGS"
.IX Header "BUGS"
Please report any bugs or feature requests to \f(CW\*(C`bug\-sub\-fp at rt.cpan.org\*(C'\fR, or through
the web interface at <https://rt.cpan.org/NoAuth/ReportBug.html?Queue=Sub\-Fp>.  I will be notified, and then you'll
automatically be notified of progress on your bug as I make changes.
.SH "SUPPORT"
.IX Header "SUPPORT"
You can find documentation for this module with the perldoc command.
.PP
.Vb 1
\&    perldoc Sub::Fp
.Ve
.PP
You can also look for information at:
.IP "\(bu" 4
\&\s-1RT: CPAN\s0's request tracker (report bugs here)
.Sp
<https://rt.cpan.org/NoAuth/Bugs.html?Dist=Sub\-Fp>
.IP "\(bu" 4
AnnoCPAN: Annotated \s-1CPAN\s0 documentation
.Sp
<http://annocpan.org/dist/Sub\-Fp>
.IP "\(bu" 4
\&\s-1CPAN\s0 Ratings
.Sp
<https://cpanratings.perl.org/d/Sub\-Fp>
.IP "\(bu" 4
Search \s-1CPAN\s0
.Sp
<https://metacpan.org/release/Sub\-Fp>
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
.SH "LICENSE AND COPYRIGHT"
.IX Header "LICENSE AND COPYRIGHT"
\&\s-1MIT\s0
.PP
Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \*(L"Software\*(R"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
.PP
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
.PP
\&\s-1THE SOFTWARE IS PROVIDED \*(L"AS IS\*(R", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\s0
